quelle taille choisir pour le buffer de lecture de la socket ? 4096 ? pourquoi ?
si pas http 1.1 on refuse ?
si on ne reconnai pas l'extention on affiche quand meme sous format html ou on gere pas ?
on peut se connecter au port 8080 de quelqu'un d'autre ??


gerer si l'extenstion n;est pas reconnu on renvoie l'erreur correspondante et virer le defaut notfound
limiter la longueur de l'url (2000 dans les navigateur classique)
est ce qu'on affiche forecement la page d'erreur quand il y a une erreur (exemple 404 et .ico)
limiter la lecture du body dans le requete
keep-alive pour eviter de creer une nouvelle connexion a chaque requete, quand il y a keep alive moi je ne dois pas close le fd, ca veut dire qu'on vas le reutiliser
reussir a parser GET /cgi-bin/script.py?name=John&age=25 HTTP/1.1
est ce qu'il faut indiquer un nom de domaine dans l'url ??
comment faire pour faire savoir qu'on a fail execve, doit on le faire savoir
ne pas blocker quand on a post et que la ressource ne mene a rien

l'index location correspond au nombre total de location et pas au nb de location de son server
a quoi sert host dans les fichier de config
la condition dans serveraction c'est pour quoi ? un test ?
est ce qu'on close les sockets dans l'enfant ?
build l'env du cgi automatiquement
faire un deuxieme cgi
write en plusieurs fois ?
faire les cookies
gerer les redirections
parser et lire en meme temps, au fur et a mesure
quoi faire quand on a pas le /usr/bin/python3

char *envp[] = {
            (char*)"REQUEST_METHOD=POST",
            (char*)(std::string("QUERY_STRING=") + this->cgi_env_var).c_str(),
            (char*)"CONTENT_TYPE=application/x-www-form-urlencoded",
            NULL
        };
        char *exec_path;
        std::string extension = this->answer.append(this->GetMime(this->ressource_path.substr(this->ressource_path.find_last_of('.'))));
        if (extension == ".py")
        {
            exec_path = (char*)"/usr/bin/python3";
        }
        else if (extension == ".php")
        {
            exec_path = (char*)"/usr/bin/php";
        }
    
        char *argv[] = { exec_path, (char*)this->ressource_path.c_str(), NULL };  // Arguments pour execve


