// bool	handleLocationParsing(std::vector<std::string> lineSplit, int *countLine, int *OCB, int *CCB, std::ifstream & file, std::string line) {
// 	std::string LocationKeyWord[] = {"root", "auto_index", "index", "allowedMethods"};

// 	if (lineSplit.size() != 3) {
// 		std::cerr << "Invalid Syntax: location need a match at line " << *countLine << std::endl;
// 		return false; 
// 	}

// 	std::string locationName = *(lineSplit.begin() + 1);
// 	// JE PENSE que pour que ca marche je dois assigner les trois valeurs
// 	// en meme temps donc
// 	// la locationName - la directive de la locationName puis sa valeur

// 	while (getline(file, line)) {
// 		// ligne vide?
// 		if (line.empty() || isOnlyWithSpace(line)) {
// 			(*countLine)++;
// 			continue ;
// 		}

// 		lineSplit = split(line);

// 		// si la ligne est } break et sortir
// 		if (*(lineSplit.begin()) == "}") {
// 			(*CCB)++;
// 			(*countLine)++;
// 			break;
// 		}
// 		// split la ligne
// 		if (lineSplit.size() == 1 && *(lineSplit.begin()) != "}") {
// 			std::cerr << "Invalid location value: At line " << *countLine << " " << *(lineSplit.begin()) << " need a value" << std::endl;
// 			return false;
// 		}
// 		// printVector(lineSplit);
// 		// parse la ligne
// 		if (!SyntaxParse(lineSplit, *countLine, OCB, CCB)) {
// 			return false;
// 		}

// 		(lineSplit.end() - 1)->erase((lineSplit.end() - 1)->size() - 1);
// 		// continuer le parsing de locationName
// 		// check si la ligne a le bon mot cle
// 		for (size_t i = 0; i < LocationKeyWord->size(); i++) {
// 			// si correspondance il y a, break il y aura
// 			if (*(lineSplit.begin()) == LocationKeyWord[i])
// 				break;
// 			// si il n'y a aucune correspondance alors mess d'err et return
// 			if (i + 1 == LocationKeyWord->size()) {
// 				std::cerr << "Invalid Syntax: Location Invalid token [" << *(lineSplit.begin()) << ']' << std::endl;
// 				return false;
// 			}
// 		}
// 		// check si les methodes autorisees de x location sont valid
// 		if (*(lineSplit.begin()) == "allowedMethods") {
// 			if (!isAllowedMethodsValid(lineSplit, *countLine))
// 				return false;
// 		}
// 		// inserer le split dans map
// 		// j'insere un vector donc j'enleve le premier car il est la directive et non la valeur
// 		std::string locationDirective = *(lineSplit.begin());
// 		lineSplit.erase(lineSplit.begin());

// 		Server::SetLocation(locationName, locationDirective, lineSplit);
// 		(*countLine)++;
// 	}
// 	// verifier si les occolades sont correctement ouvert et ferme
// 	return true;
// }


// AUTO INDEX

// bool	Server::handleAutoIndex(std::vector<std::string> lineSplit, int countLine) {
// 	if (lineSplit.size() != 2) {
// 		std::cerr << "Invalid Syntax: at line " << countLine << " Autoindex need a value (on or off)" << std::endl;
// 		return false;
// 	}
// 	std::cout << "line begin = " << *(lineSplit.begin() + 1) << " avant" << std::endl;
// 	*(lineSplit.begin() + 1)->erase((lineSplit.begin() + 1)->end() - 1);
// 	std::cout << "line begin = " << *(lineSplit.begin() + 1) << " apres" << std::endl;

// 	if (*(lineSplit.begin() + 1) != "on" && *(lineSplit.begin() + 1) != "off") {
// 		std::cerr << "Invalid AutoIndex Value at line " << countLine << " it must be on or off" << std::endl;
// 		return false;
// 	}
// 	if (*(lineSplit.begin() + 1) == "on")
// 		SetAutoIndex(1);

// 	else
// 		SetAutoIndex(0);
// 	return true;
// }

// ALLOWED METHODS
